cc.Class({
    extends: cc.Component,

    properties: {

    },

    onLoad() {
        //---变量
        //1---基本类型值---简单的数据段
        //1.1---基本数据类型，可以操作保存在变量中的实际值：Undefined，Null，Boolean，Number，String
        //1.2---按值访问
        //1.3---保存在栈的内存中，在内存中占据固定大小的空间
        //2---引用类型值---某个特定引用类型的一个实例；可能由多个值构成的对象；引用类型是一种数据结构，用于将数据和功能组织在一起
        //1.1---保存在内存中的对象，JS不允许直接访问内存中的位置，即不能直接操作对象的内存空间
        //1.2---按引用访问
        //1.3---保存在堆内存中，数据长度是变化的，同时栈内存中有一个指针指向这个对象
        //1.4---包含引用类型值的变量实际上包含并不是对象本身，而是一个指向该对象的指针
        //3---复制变量值
        //3.1---复制基本类型值---创建一个值的副本，2个值互不影响
        var num1 = 1;
        var num2 = num1; //num2中的1与num1中1是完全独立的，该值只是num1中1的一个副本
        //3.2---复制引用类型值---创建一个指针，这个指针指向存储在堆内存中的一个对象
        var obj1 = new Object();
        var obj2 = obj1; //2个变量将引用同一个对象，改变其中一个变量将会影响到另一个变量
        obj1.name = 'damon';
        console.log('obj2.name = ' + obj2.name); //damon
        //4---传递参数---ECMAScript中所有函数的参数都是按值传递的
        //4.1---向参数传递基本类型值---将值的副本复制给一个局部变量（即命名参数，作为arguments对象中的一个元素）
        function addTen(num) {
            num += 10;
            return num;
        }
        var num = 1;
        addTen(num);
        console.log('num = ' + num); //1
        //4.2---向参数传递引用类型值---将值在内存中的地址复制给一个局部变量，这个局部变量的变化会反映再函数的外部
        function setName(obj, rewrite = false) {
            //实参按值传递给形参
            obj.name = 'damon';
            if (rewrite) {
                obj = new Object(); //重写obj（与外部实参无关），此时该变量引用的是一个局部对象，这个对象在函数执行完毕后立即销毁
                obj.name = 'stefan';
            }
        }
        var person1 = new Object();
        setName(person1);
        console.log('person1.name = ' + person1.name); //damon
        var person2 = new Object();
        setName(person2, true);
        console.log('person2.name = ' + person2.name); //damon
        //5---检测类型
        //5.1---typeof操作符---检测基本类型
        //5.2---instanceof操作符---检测引用类型
        //6---变量声明
        var i = 1;
        console.log('i = ' + i); //1
        var i; //重新声明变量，视而不见，但会执行后续声明中变量的初始化
        console.log('i = ' + i); //1
        var i = 2;
        console.log('i = ' + i); //2

        //---执行环境（也称作用域）
        //1---执行环境简介
        //1.1---定义了变量或函数有权访问的其他数据
        //1.2---每一个执行环境都有一个与之关联的变量对象，环境中定义的所有变量和函数都保存在这个对象中
        //1.3---全局执行环境---最外围的一个执行环境
        //1.4---每个函数都有自己的执行环境---当执行流进入一个函数时，函数的环境就会被推入一个环境栈中，在函数执行之后，栈将其环境弹出，把控制权返回给之前的执行环境
        //2---作用域链---用于搜索变量和函数，每次进入一个新的执行环境时创建
        //2.1---当代码在一个环境中执行时，会创建变量对象的一个作用域链：变量对象1-变量对象2-...---本质上是一个指向变量对象的指针列表，它只引用但不实际包含变量对象
        //2.2---作用域链的用途---保证对执行环境有权访问的所有变量和函数的有序访问
        //2.3---作用域链的前端---始终都是当前执行的代码所在环境的变量对象；如果这个环境是函数，则将其活动对象作为变量对象（活动对象在最开始时，只包含一个变量arguments对象，再全局环境中是不存在的）
        //2.4---作用域链的下一个变量对象来自包含（外部）环境，再下一个变量对象，来自下一个外部环境，一直延续到全局执行环境
        //2.5---全局执行环境的变量对象始终都是作用域链中的最后一个对象
        //3---内部环境可以通过作用域访问所有的外部环境，但外部环境不能访问内部环境中的任何变量和函数；每个环境可以向上（外部）搜索作用域链，以查询变量和函数名
        var color = 'bule';
        //全局环境的变量对象---变量color，函数changeColor
        //changeColor局部环境的变量对象（即函数的活动对象）---arguments对象，变量anotherColor，函数swapColor
        function changeColor() {
            var anotherColor = 'red';
            //swapColor局部环境的变量对象---arguments对象，变量tempColor
            function swapColor() {
                var tempColor = anotherColor;
                anotherColor = color;
                color = tempColor;
            }
            swapColor();
        }
        //4---没有块级作用域
        //4.1---声明变量---使用var声明的变量会自动添加到最接近的环境中
        //在函数的内部，最接近的环境-函数的局部环境
        //4.2---查询标志符---搜索过程从作用域链的前端开始，向上逐级查询与给定名字匹配的标志符
        //步骤---1---如果在局部环境中找到了该标志符，搜索过程停止，变量就绪
        //步骤---2---如果在局部环境中没有找到该变量名，则继续沿作用域链向上搜索
        //步骤---3---搜索过程一直追溯到全局环境的变量对象
        //步骤---4---如果再全局环境中也没有找到这个标志符，则意味着该变量尚未声明

        //---垃圾收集
        //1---方式
        //1.1---标记清除
        //当变量进入环境时，就将这个变量标记为"进入环境"，如在函数中声明一个变量
        //当变量离开环境时，则将其标记为"离开环境"
        //1.2---引用计数（不太常见）
        //跟踪记录每个值被引用的次数
        //当声明了一个变量并将一个引用类型值赋给变量时，则这个值的引用次数为1
        //如果同一个值又被赋给另一个变量，则该值的引用计数+1；如果包含这个值引用的变量又取了另一个值，则这个值的引用计数-1
        //当这个值的引用次数变为0时，则说明没有办法再访问这个值了，因此回收其占用的内存空间
        //问题---循环引用
        //2---性能问题---垃圾收集器是周期性运行的
        //3---管理内存
        //解除引用---将值设置为null来释放其引用：让值脱离执行环境，以便垃圾收集器再下次运行时将其回收，并不意味着自动回收该值所在的内存



    },

    // start() {},

    // update (dt) {}
});