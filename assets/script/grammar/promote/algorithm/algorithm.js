cc.Class({
    extends: cc.Component,

    properties: {

    },

    onLoad() {
        //---算法---解决特定问题求解步骤的描述
        //在计算机中表现为指令的有限序列，并且每条指令表示一个或多个操作

        //---算法的特性
        //1---输入---0个或多个
        //2---输出---1个或多个
        //3---有穷性---算法在执行有限的步骤之后，自动结束而不会出现无限循环，并且每一个步骤在可接受的时间内完成
        //4---确定性---算法的每一步骤都具有确定的含义，不会出现二义性；算法在一定条件下，只有一条执行路径，相同的输入只能有唯一的输出结果
        //5---可行性---算法的每一步骤都必须是可行的；每一步都能通过执行有限次数完成

        //---算法的设计要求
        //1---正确性
        //1.1---算法程序没有语法错误
        //1.2---算法程序对于合法的输入数据能够产生满足要求的输出结果
        //1.3---算法程序对于非法的输入数据能够得出满足规格说明的结果
        //1.4---算法程序对于精心选择的，甚至刁难的测试数据都有满足要求的输出结果
        //2---可读性
        //3---健壮性---当输入数据不合法时，算法也能做出相关处理，而不是产生异常或莫名其妙的结果
        //4---时间效率高和存储量低
        //时间效率---算法的执行时间
        //存储量需求---算法在执行过程中需要的最大存储空间

        //---算法效率的度量方法
        //1---事后统计法
        //通过设计好的测试程序和数据，利用计算机计时器对不同算法编制的程序的运行时间进行比较，从而确定算法效率的高低
        //缺陷---1---事先编制好程序
        //缺陷---2---时间的比较依赖计算机硬件和软件等环境因素
        //缺陷---3---测试数据设计苦难
        //不予采纳事后统计法
        //2---事前分析估算方法
        //理论依据---通过算法时间复杂度来估算算法时间效率
        //在计算机程序编制前，依据统计方法对算法进行估算
        //一个程序的运行时间，依赖于算法的好坏和问题的输入规模
        //分析一个算法的运行时间时，重要的是把基本操作的数量与输入规模关联起来；即基本操作的数量必须表示成输入规模的函数（f(n)~n）

        //---函数的渐近增长
        //给定2个函数f(n)和g(n)，如果存在一个整数N，使得对于所有的n>N，f(n)总比g(n)大，那么f(n)的增长渐近快于g(n)
        //随着n的增大：可以忽略加法常数；可以忽略最高次项相乘的常数；最高次项的指数越大，增长越快
        //判断一个算法的效率时，可以忽略常数和其他次要项，关注主项（最高阶项）的阶数

        //---算法的时间复杂度（算法的时间量度）
        //1---算法时间复杂度的定义---T(n) = O(f(n))---表示随着n的增大，算法执行时间的增长率和f(n)的增长率相同，称作算法的渐近时间复杂度
        //T(n)---语句总的执行次数；是关于问题规模n的函数
        //O()---表示算法时间复杂度的记法（大O记法）
        //一般情况下，随着n的增大，T(n)增长最慢的算法为最优算法
        //2---推导大O阶方法
        //2.1---用常数1取代运行时间中的所有加法常数
        //2.2---在修改后的运行次数函数中，只保留最高阶项
        //2.3---如果最高阶项存在且不是1，则去除与这个项相乘的常数
        //3---常数阶---O(1)
        //顺序结构的时间复杂度
        //单纯的分支结构（不包括在循环结构中）的时间复杂度
        //4---线性阶---O(n)
        //线性阶的循环结构
        // for (let i = 0; i < n; i++) {
        //     //循环体中的代码需要执行n次
        //     //时间复杂度为O(1)的程序步骤序列
        // }
        //5---对数阶---O(logn)
        // var count = 1;
        // while (count < n) {
        //     count = count * 2; //2^x = n
        //     //时间复杂度为O(1)的程序步骤序列
        // }
        //6---平方阶---O(n2)
        //循环的时间复杂度 = 循环体的复杂度 * 循环运行次数

        //---算法的空间复杂度---通过计算算法所需的存储空间实现
        //公式---S(n) = O(f(n))
        //n---问题规模
        //f(n)---语句关于n所占存储空间的函数

    },

    // start() {},

    // update (dt) {}
});